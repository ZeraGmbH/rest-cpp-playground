/**
 * SourceApi
 * A Web API for controlling a source.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonParseError>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIVeinApiHandler.h"
#include "OAIVeinApiRequest.h"

namespace OpenAPI {

OAIVeinApiHandler::OAIVeinApiHandler(VeinEntryPtr veinEntry) : m_veinEntry(veinEntry)
{

}

OAIVeinApiHandler::~OAIVeinApiHandler(){

}

QList<OAIVeinGetResponse> OAIVeinApiHandler::generateBulkAnswer(QList<OAIVeinGetRequest> oai_vein_get_request)
{
    QList<OAIVeinGetResponse> response;

    for (const auto &item : oai_vein_get_request)
    {
        int entityId = item.getEntityId();
        QString componentName = item.getComponentName();
        OAIVeinGetResponse responseEntry;
        VeinStorage::AbstractDatabase* storage = m_veinEntry->getStorageDb();

        responseEntry.setComponentName(componentName);
        responseEntry.setEntityId(entityId);

        if(storage->hasStoredValue(item.getEntityId(), item.getComponentName())){
            QVariant value = storage->getStoredValue(item.getEntityId(), item.getComponentName());
            QString returnValue = variantToJsonString(value);
            responseEntry.setType(value.typeName());
            if(returnValue != "null")
            {
                responseEntry.setReturnInformation(returnValue);
                responseEntry.setStatus(200);
            }
            else
            {
                responseEntry.setReturnInformation("null");
                responseEntry.setStatus(422);
                responseEntry.setType("Invalid");
            }

        }
        else
        {
            responseEntry.setStatus(422);
            responseEntry.setType("Invalid");
            responseEntry.setReturnInformation("\"Timeout or not existing entity or component\"");
        }

        response.append(responseEntry);
    }
    return response;
}

QString OAIVeinApiHandler::variantToJsonString(QVariant input)
{
    QString typeName = input.typeName();
    QString returnValue;

    QMetaType::Type dataType = static_cast<QMetaType::Type>(input.type());

    if (dataType == QMetaType::QByteArray) {
          returnValue = QString(*static_cast<const QByteArray *>(input.constData()));
    }
    else if (dataType == QMetaType::QJsonObject || dataType == QMetaType::QVariantMap) {
        QJsonObject jsonObj = QJsonValue::fromVariant(input).toObject();
        QJsonDocument doc = QJsonDocument(jsonObj);
        returnValue = doc.toJson(QJsonDocument::Compact);
    }
    else if (dataType == QMetaType::QJsonArray) {
        QJsonArray jsonObj = QJsonValue::fromVariant(input).toArray();
        QJsonDocument doc = QJsonDocument(jsonObj);
        returnValue = doc.toJson(QJsonDocument::Compact);
    }
    else if(typeName.contains("List"))
    {
        QVariantList list = input.value<QVariantList>();
        QJsonArray jsonArray;
        for (const QVariant& item : list)
        {
            jsonArray.append(QJsonValue::fromVariant(item));
        }
        QJsonDocument doc = QJsonDocument(jsonArray);
        returnValue = doc.toJson(QJsonDocument::Compact);
    }
    else {
        QJsonValue jsonValue = QJsonValue::fromVariant(input);
        QJsonDocument doc = QJsonDocument(QJsonArray{jsonValue});
        QString serialized = doc.toJson(QJsonDocument::Compact);
        returnValue = serialized.mid(1, serialized.length() - 2);
    }

    return returnValue;
}

OAIRpcResponse OAIVeinApiHandler::getRPCAnswer(OAIRpcRequest rpc_request, bool rpcfound, bool rpcSuccessful, QVariant result, QString errorMsg)
{
    OAIRpcResponse response;
    int entityId = rpc_request.getEntityId();
    QString rpcName = rpc_request.getRpcName();
    VeinStorage::AbstractDatabase* storage = m_veinEntry->getStorageDb();

    response.setRpcName(rpcName);
    response.setEntityId(entityId);

    QString typeName(result.typeName());

    if(!rpcfound) {
        response.setStatus(400);
        response.setReturnInformation("\"RPC not reachable. Check EntityId or RpcName\"");
    }
    else {
        if(!rpcSuccessful) {
            response.setStatus(422);
            response.setReturnInformation("\"" + errorMsg + "\"");
        }
        else {
            if(typeName == "bool" || typeName == "int" || typeName == "QByteArray") {
                response.setReturnInformation(result.toString());
                response.setStatus(200);
            }
            else if(typeName == "QVariantMap" || typeName == "QJsonArray" || typeName == "QVariantList") {
                response.setReturnInformation(variantToJsonString(result));
                response.setStatus(200);
            }
            else {
                response.setStatus(501);
                response.setReturnInformation("\"RPC response type isn't implemented.\"");
            }
        }
    }
    return response;
}


void OAIVeinApiHandler::apiV1VeinGet(qint32 entity_id, QString component_name) {
    Q_UNUSED(entity_id);
    Q_UNUSED(component_name);
    auto reqObj = qobject_cast<OAIVeinApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        OAIVeinGetRequest request;
        request.setEntityId(entity_id);
        request.setComponentName(component_name);
        std::shared_ptr<SubscriptionManager> subscriptionManager = m_veinEntry->getSubscriptionManager();
        QList<int> entitiesRequested = QList<int>() << entity_id;

        std::shared_ptr<QMetaObject::Connection> conn = std::make_shared<QMetaObject::Connection>();
        *conn = connect(subscriptionManager.get(), &SubscriptionManager::finishedSubscribing, this, [&, request, reqObj, conn](bool ok){
            QList<OAIVeinGetResponse> res;
            res = generateBulkAnswer(QList<OAIVeinGetRequest>() << request);

            reqObj->apiV1VeinGetResponse(res[0]);
            disconnect(*conn);
        });

        subscriptionManager->subscribeToEntities(entitiesRequested);
    }
}

void OAIVeinApiHandler::apiV1VeinPost(QList<OAIVeinGetRequest> oai_vein_get_request) {
    Q_UNUSED(oai_vein_get_request);
    auto reqObj = qobject_cast<OAIVeinApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        std::shared_ptr<SubscriptionManager> subscriptionManager = m_veinEntry->getSubscriptionManager();
        QList<int> entitiesRequested;
        for (const auto &item : oai_vein_get_request)
            if(!entitiesRequested.contains(item.getEntityId()))
                entitiesRequested.append(item.getEntityId());

        std::shared_ptr<QMetaObject::Connection> conn = std::make_shared<QMetaObject::Connection>();
        *conn = connect(subscriptionManager.get(), &SubscriptionManager::finishedSubscribing, this, [&, oai_vein_get_request, reqObj, conn](bool ok){
            QList<OAIVeinGetResponse> res;
            res = generateBulkAnswer(oai_vein_get_request);

            reqObj->apiV1VeinPostResponse(res);
            disconnect(*conn);
        });

        subscriptionManager->subscribeToEntities(entitiesRequested);

    }
}

void OAIVeinApiHandler::apiV1VeinRpcPost(OAIRpcRequest oai_rpc_request) {
    auto reqObj = qobject_cast<OAIVeinApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        OAIRpcResponse res;
        QVariantMap parametersMap;

        QList<OAIRpcRequest_Parameters_inner> parameterList = oai_rpc_request.getParameters();

        for(int i = 0; i < parameterList.length(); i++)
            parametersMap.insert(parameterList.at(i).getKey(), parameterList.at(i).getValue());

        std::shared_ptr<bool> rpcSuccessful = std::make_shared<bool>();
        std::shared_ptr<QVariant> result = std::make_shared<QVariant>();
        std::shared_ptr<QString> errorMsg = std::make_shared<QString>();

        std::shared_ptr<TaskTemplate> taskSharedPtr =
            m_veinEntry->rpcToVein(
                oai_rpc_request.getEntityId(),
                oai_rpc_request.getRpcName(),
                parametersMap,
                rpcSuccessful,
                result,
                errorMsg,
                oai_rpc_request.is_timeout_Set() ? oai_rpc_request.getTimeout() : 1000
            );

        auto conn = std::make_shared<QMetaObject::Connection>();

        *conn = connect(taskSharedPtr.get(), &TaskTemplate::sigFinish, this,
                        [conn, reqObj, res, taskSharedPtr, oai_rpc_request, rpcSuccessful, result, errorMsg, this](bool ok, int taskId){
            OAIRpcResponse res = getRPCAnswer(oai_rpc_request, ok, *rpcSuccessful, *result, *errorMsg);
            reqObj->apiV1VeinRpcPostResponse(res);
            disconnect(*conn);
        });
        taskSharedPtr->start();
    }
}

void OAIVeinApiHandler::apiV1VeinPut(OAIVeinSet oai_vein_set) {
    auto reqObj = qobject_cast<OAIVeinApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        TaskTemplatePtr task = m_veinEntry->setToVein(oai_vein_set.getEntityId(),oai_vein_set.getComponentName(), oai_vein_set.getNewValue());
        std::shared_ptr<TaskTemplate> taskSharedPtr = std::move(task);

        if (!oai_vein_set.is_entity_id_Valid() || !oai_vein_set.is_component_name_Valid() || !oai_vein_set.is_new_value_Valid())
        {
            OAIProblemDetails res;
            res.setStatus(400);
            res.setDetail("Input not valid: Entity Id or Component name");
            res.setTitle("Setter command output");
            res.setType("");
            reqObj->apiV1VeinPutResponse(res);
            return;
        }

        std::shared_ptr<QMetaObject::Connection> conn = std::make_shared<QMetaObject::Connection>();
        *conn = connect(taskSharedPtr.get(), &TaskTemplate::sigFinish, this, [conn, reqObj, taskSharedPtr, oai_vein_set](bool ok, int taskId){
            OAIProblemDetails res;
            if (ok)
                res.setStatus(200);
            else
                res.setStatus(422);

            QString str = "Entity Id: " + QString::number(oai_vein_set.getEntityId()) + " Component name: " + oai_vein_set.getComponentName() + " New Value: " + oai_vein_set.getNewValue();
            res.setDetail(str);
            res.setTitle("Setter command output");
            res.setType("");
            reqObj->apiV1VeinPutResponse(res);
            disconnect(*conn);
        });
        taskSharedPtr->start();
    }
}
}
